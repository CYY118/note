#### 请你说说线程和协程的区别

解题思路

  得分点 地址空间、开销、并发性、内存  标准回答 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。 

1. 进程有独立的地址空间,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间； 

2. 进程和线程切换时,需要切换进程和线程的上下文,进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些； 

3. 进程的并发性较低,线程的并发性较高； 

4. 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制； 

5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言,除了 CPU 外,系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源）,线程组之间只能共享资源； 

6. 一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 

   

#### 请你说说MySQL索引,以及它们的好处和坏处

解题思路

得分点 检索效率、存储资源、索引维护  标准回答  索引就像指向表行的指针,是一种允许查询操作快速确定哪些行符合WHERE子句中的条件,并检索到这些行的其他列值的数据结构；  索引主要有普通索引、唯一索引、主键索引、外键索引、全文索引、复合索引几种；  在大数据量的查询中,合理使用索引的优点非常明显,不仅能大幅提高匹配where条件的检索效率,还能用于排序和分组操作的加速。  当时索引如果使用不当也有比较大的坏处：比如索引必定会增加存储资源的消耗；同时也增大了插入、更新和删除操作的维护成本,因为每个增删改操作后相应列的索引都必须被更新。  加分回答 只要创建了索引,就一定会走索引吗？ 不一定。  比如,在使用组合索引的时候,如果没有遵从“最左前缀”的原则进行搜索,则索引是不起作用的。  举例,假设在id、name、age字段上已经成功建立了一个名为MultiIdx的组合索引。索引行中按id、name、age的顺序存放,索引可以搜索id、（id,name）、（id, name,  age）字段组合。如果列不构成索引最左面的前缀,那么MySQL不能使用局部索引,如（age）或者（name,age）组合则不能使用该索引查询。



## Java的特点

### **Java具有平台独立性和移植性**。

- Java有一句口号：`Write once, run anywhere`，一次编写、到处运行。这也是Java的魅力所在。而实现这种特性的正是Java虚拟机JVM。已编译的Java程序可以在任何带有JVM的平台上运行。你可以在windows平台编写代码，然后拿到linux上运行。只要你在编写完代码后，将代码编译成.class文件，再把class文件打成Java包，这个jar包就可以在不同的平台上运行了。

### **Java具有稳健性**。

- Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。
- 异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用`try/catch/finally`语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。

## Java 与 C++ 的区别

- Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 兼容 C ，不但支持面向对象也支持面向过程。
- Java 通过虚拟机从而实现跨平台特性， C++ 依赖于特定的平台。
- Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
- Java 支持自动垃圾回收，而 C++ 需要手动回收。
- Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。

## 面向对象和面向过程的区别？

**面向对象和面向过程是一种软件开发思想。**

- 面向过程就是分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了。
- 面向对象是把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成有完整功能的系统。面向过程只用函数实现，面向对象是用类实现各个功能模块。

**以五子棋为例，面向过程的设计思路就是首先分析问题的步骤：**

1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。 把上面每个步骤用分别的函数来实现，问题就解决了。

而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为：

1. 黑白双方
2. 棋盘系统，负责绘制画面
3. 规则系统，负责判定诸如犯规、输赢等。

黑白双方负责接受用户的输入，并告知棋盘系统棋子布局发生变化，棋盘系统接收到了棋子的变化的信息就负责在屏幕上面显示出这种变化，同时利用规则系统来对棋局进行判定。

## JDK/JRE/JVM三者的关系

### **JVM**

英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。Java 能够跨平台运行的核心在于 JVM 。

![image-20230323142148386](https://gitee.com/yangstudys/typora-pic/raw/master/prcture/202303231421483.png)

所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。也就是说class文件并不直接与机器的操作系统交互，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。

针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。这就是Java能够跨平台，实现一次编写，多处运行的原因所在。

### **JRE**

英文名称（Java Runtime Environment），就是Java 运行时环境。我们编写的Java程序必须要在JRE才能运行。它主要包含两个部分，JVM 和 Java 核心类库。

![image-20230323142813747](https://gitee.com/yangstudys/typora-pic/raw/master/prcture/202303231428796.png)

JRE是Java的运行环境，并不是一个开发环境，所以没有包含任何开发工具，如编译器和调试器等。

如果你只是想运行Java程序，而不是开发Java程序的话，那么你只需要安装JRE即可。

### **JDK**

英文名称（Java Development Kit），就是 Java 开发工具包

学过Java的同学，都应该安装过JDK。当我们安装完JDK之后，目录结构是这样的

![image-20230323142910050](https://gitee.com/yangstudys/typora-pic/raw/master/prcture/202303231429109.png)

可以看到，JDK目录下有个JRE，也就是JDK中已经集成了 JRE，不用单独安装JRE。

另外，JDK中还有一些好用的工具，如jinfo，jps，jstack等。

![image-20230323142940196](https://gitee.com/yangstudys/typora-pic/raw/master/prcture/202303231429294.png)

最后，总结一下JDK/JRE/JVM，他们三者的关系

**JRE = JVM + Java 核心类库**

**JDK = JRE + Java工具 + 编译器 + 调试器**

![image-20230323143017741](https://gitee.com/yangstudys/typora-pic/raw/master/prcture/202303231430801.png)

## 面向对象有哪些特性？

面向对象四大特性：封装，继承，多态，抽象

1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 良好的封装能够减少耦合。

2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在Java中是单继承的，也就是说一个子类只有一个父类。

3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。

- 静态多态性：通过重载实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。
- 动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。

4、抽象。把客观事物用代码抽象出来。

## Java的基本数据类型有哪些？

- byte，8bit
- char，16bit
- short，16bit
- int，32bit
- float，32bit
- long，64bit
- double，64bit
- boolean，只有两个值：true、false，可以使⽤用 1 bit 来存储

在Java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了单个boolean占4个字节，和boolean数组1个字节的定义，具体 **还要看虚拟机实现是否按照规范来**，因此boolean占用1个字节或者4个字节都是有可能的。

## socket的过程



## 1.1 什么是微服务？



## 1.2 微服务之间是如何独立通讯的？



## 1.3 SpringCloud和Dubbo有那些区别？



## 1.4 SpringBoot和SpringCloud，请你谈谈对他们的理解



## 1.5 什么是服务器熔断？什么是服务降级



## 1.6 微服务的优缺点分别是什么？说下你在项目中开发中遇到的坑



## 1.7 你所知道的微服务技术栈有哪些？请举例一二



## 1.8 eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？



## 1.9 Nginx反向代理技术



## 2.0 js中的“= =” 和 "= = =" 的区别

> 两种符号的定义：
>
> ​	"=="：叫做相等运算符
>
> ​	"==="：叫做严格相等运算符（全等运算符）
>
> 它们之间的区别
>
> ​	"=="：只判断等号两边的值是否相等，而不是判断类型是否相同。值相同则返回 true
>
> ​	"==="：既要判断值是否相等，也要判断类型是否相同，即全等才能返回 true
>
> #### 分析 "=="：
>
> 1. undefined和null互相比较返回true，和自身比较也返回true，其他情况返回false
> 2. Infinity 只和自身比较返回true
> 3. NaN，{}和任意值比较都是返回false
> 4. 如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false，则将其转换为0再进行比较
> 5. 要比较相等性之前，不能将null和undefined转换成其他任何值
> 6. 如果一个值是数字，另一个是字符串，先将字符串转换为数值，然后使用转换后的值进行比较
> 7. 如果等号两侧都是对象，则比较它们是否为同一个对象，如果指向同一个对象，则返回true，否则返回false
>
> #### 分析"==="：
>
> 1. 先分析是否为相同类型，如果类型不同直接返回false
>
>    如果类型相同，
>
>    ​	基本类型，直接比较值是否相同，
>
>    ​	对象类型，由于对象类型保存的是对象（包括数组，对象）的地址值，所以地址值不同的，返回的都是false。地址值相同，返回true



## 2.1 在redis中缓存的值，如果redis被重启了数据可能会丢失应该怎么避免

![image-20230613152342281](https://gitee.com/yangstudys/typora-pic/raw/master/prcture/202306131523868.png)

> 要避免上述问题我们需要做的就是redis数据的持久化，如果把redis的持久化做好，备份和恢复方案做到企业级的程度，那么即使你的redis故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务
>
> #### Redis持久化数据的两种模式
>
> ##### 一、RDB模式
>
> 1. redis默认启用的本地化模式
>
> 2. 每隔一段时间全量备份；系统将导出的dump.rdb文件备份
>
>    ```yml
>    save 900 1  #900秒内 至少1个key被更新 就全量备份RDB
>    save 300 10
>    save 60 10000
>    ```
>
> 3. 原理：redis会fork一个新的进程来进行rdb全量结构化。（redis本身读写是单进程的）
>
> 4. 缺点：备份后和故障间 数据丢失；新的fork的子进程会copy父进程里的内存数据进行备份，会造成内存的瞬间翻倍。
>
> 二、AOF模式
>
> 1. AppendOnlyFile的缩写，是一种增量备份模式，Redis默认不开启
>
> 2. 类似mysql数据库的binlog，记录所有的redis操作记录
>
>    ```yml
>    appendonly yes #开启AOF
>    appendfilename "aooendonly.aof" #设置备份文件名
>    appendfsync everysec #每秒更新一次操作记录
>    ```
>
> 3. reids会在原有进程的基础上，重新fork一个子进程进行记录
>
> 4. 日志形式记录写操作；以文件追加的方式记录（在同一个备份文件上追加操作记录）
>
> 三、RDB和AOF之间的关系
>
> 1. 优先级AOF > RDB
> 2. RDB  和 AOF之间是不会相互通信的

## 2.1 Redi缓存的三大问题

1. ### 缓存穿透

   缓存穿透是指前端请求到达后端服务器后，先从Redis缓存中查询，没有查询到结果，然后查询数据库，数据库查询不到数据则不进行数据缓存。流程图示如下

   ![image-20230614092309208](https://gitee.com/yangstudys/typora-pic/raw/master/prcture/202306140923267.png)

   这种在代码逻辑上会先查询redis，再查询数据库。逻辑上redis有一层缓存，但是实际情况却是redis并未起到缓存的真正作用，使得请求全部进入数据库查询，数据库也没有查询到数据，数据库没有查询到数据之后也没有进行空对象写入缓存。这种情况，称之为**缓存穿透**！在低并发情况下，数据库可以承受住压力的话。存在缓存穿透时对系统影响不大，但是在高并发的场景下，大量请求对数据库会造成很大的压力，极有可能直接使得数据库宕机影响系统的使用，这种是需要极力避免的。处理办法有常见的两种，数据库查询后缓存和布隆过滤器。

   #### 1.1数据库查询后缓存

   ![image-20230614094431239](https://gitee.com/yangstudys/typora-pic/raw/master/prcture/202306140944307.png)

   请求先通过redis查询，没有查询到数据，然后请求数据库，将数据库查询结果进行redis缓存，然后响应前端请求；当在数据库中也没有查询到数据时，也会将null缓存到redis中，这样后续的请求也会走redis，但是这种方式也是有弊端的，第一次请求还是会走到数据库中，在高并发的情况下，数据库压力其实也很大。一般不采用这种方式来处理

   #### 1.2布隆过滤器（Bloom Filter）

   根据布隆过滤器的特点，如果布隆过滤器判定没有，就一定没有，可以帮助服务端过滤非法数据的请求，即Redis没有相关，数据库也没有相关数据的请求。在使用布隆过滤器的时候，有个前置条件，就是需要将校验数据提前在布隆过滤器中进行存储。当布隆过滤器判断请求的数据不存在时，直接返回响应，避免对数据库造成很大的压力。

2. ### 缓存击穿

   系统中都存在某个或许某些热点数据，访问量特别大，当大量请求进入服务器后，遇上缓存失效，缓存不存在导致大量的请求直接访问数据库，给数据库造成过大的压力，称为缓存击穿。

   #### 2.1 合理设置热点数据过期时间

   ​        热点数据在缓存的时候，根据实际的业务常见，估算充裕的缓存的失效时间，例如某个活动的投放时间是10个小时，这10个小时候的访问量肯定较大。但是10个小时候，就可以保证并发量一定会出现大幅下降吗？我个人觉得不一定。所以我们在设置这个热点key的过期时间是，可以设置20小时，甚至24小时。这样会更加的保险。具体的时间还得根据具体的场景设置。

   #### 2.2 加锁访问

   ​        热点数据设置合理的过期时间，是一个有效方案，但是这个方案对系统压力还是很大。此时为了保护系统的稳定性，还需要有其他的手段来处理，加锁访问就是一种比较有效的手段。加锁的方式有很多种，如果是单节点，Java自带的synchronized就可以实现，但实际情况往往不大可能。现在都是集群部分来保证服务的高可用性。所以在加锁时，需要使用分布式锁。可以使用比较常用，例如：redisson等。

3. ### 缓存雪崩

   缓存雪崩，字面意思也比较好理解，就是缓存的数据出现雪崩。大面积的缓存数据或者所有的缓存数据都失效，所有的请求全部进入数据库查询的情况。缓存雪崩实际上不大可能是程序问题，更大的概率是由于其他因素导致，例如服务器断电等等。处理缓存雪崩，我个人认为更多的是得从运维的角度来处理，比如服务器集群部署，服务器多区域部署。另外还可以通过服务降级，服务限流等方面入手处理。
